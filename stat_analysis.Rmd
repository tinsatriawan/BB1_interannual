---
title: "stat_analysis"
author: "Tin Satriawan"
date: "31/01/2022"
output: 
  word_document: 
    reference_docx: "stat_analysis.docx"
editor_options: 
  
  chunk_output_type: console
---

```{r setup, include = F}

# data wrangling 
source("data_wrangling.R")

library(car)
library(MASS)
library(leaps)
library(flextable)
library(nlme)

# set chunks defaults
knitr::opts_chunk$set(
  echo       = FALSE,
  message    = FALSE,
  warning    = FALSE
)

# set flextable defaults
knitr::opts_chunk$set(echo = TRUE, fig.cap = TRUE)
  set_flextable_defaults(
  font.family = "Arial", font.size = 9, 
  theme_fun = "theme_vanilla",
  big.mark="", table.layout="autofit")

```


```{r functions, echo = F}

# plot MLR assumptions diagnostics
plot_diagnostics <- function(input, model, type = "co2gC"){
  
  sum <- summary(model)
  # save diagnostics
  input$yhat <- fitted(model)
  input$resid <- residuals(model)
  input$stdresid <- residuals(model)/sum$sigma

  # Diagnotic plots
  windows()
  par(mfrow=c(2,2),cex=1.1,mai=c(1.1,1.1,0.5,0.4))
  # Fitted line plot. Predicted y versus observed y.
    plot(input$yhat ~ eval(parse(text = paste("input$", type))),xlab="Volume/ha",
  ylab="yhat",main="Predicted vs Actual Volume/ha",
  pch=19)
  abline(a=0,b=1,col="red")
  # Residual plot
  plot(input$yhat, input$resid,xlab = "yhat",
  ylab = "Residual",main = "Residual Plot",pch = 19)
  abline(h=0, col="red")
  # Normality plot
  qqnorm(input$stdresid, ylab = "Std. Residual", pch =19)
  qqline(input$stdresid, col ="red")
  # Histogram of residuals
  hist(input$resid,breaks = 5,xlab = "Std. Residual",
  main = "Std. Residuals", col="grey", border="black")
  par(mfrow=c(1,1),cex=1.1,mai=c(1.1,1.1,1.0,1.0))
  
}

calc_model <- function(input, model, type = "co2gC"){
  sum <- summary(model)
  output <- data.frame(date = input$date,
                       period = input$period,
                       observed = eval(parse(text = paste("input$", type))), 
                       yhat = fitted(model), 
                       resid = residuals(model), 
                       stdresid = residuals(model)/sum$sigma)
  # output$observed <- eval(parse(text = paste("input$", type)))
  # output$yhat <- fitted(model)
  # output$resid <- residuals(model)
  # output$stdresid <- residuals(model)/sum$sigma
  output
}

## function for calculating yearly MLR 

calc_yearly_MLR <- function(input, n_period, scope, type, ...) {
  
  # filter input to get each period 
  filtered_input <- as.data.frame(input) %>%
             dplyr::filter(period == n_period) %>% 
             dplyr::select(-c(date, period))
  model.null <- eval(parse(text = paste0("lm(", type, "~ 1, data = filtered_input)")))
  model.step <- stepAIC(model.null, 
                        scope = scope, 
                        trace = T, 
                        ...) 
  print(model.step)
  
  # AIC result 
  result <- model.step[["anova"]][-1, ]
  
  # get AIC, R2, adj R2 per variable added
  result_per_variable <- data.frame(variable = NA, 
                                    AIC = NA, 
                                    R2 = NA,
                                    adjR2 = NA)
  
  for(i in 1:nrow(result)){
    if(i == 1) {
      step <- NA
      step <- paste0("~1", result$Step[i])
    } else { 
      step <- paste0(step, result$Step[i])
      }
    model <- eval(parse(text = paste0("lm(", type, step, ", data = filtered_input)")))
    # print diagonstic plots
    print(plot_diagnostics(filtered_input, model, type))
    result_per_variable[i, "variable"] <- result$Step[i]
    result_per_variable[i, "AIC"] <- result$AIC[i]
    result_per_variable[i, "R2"] <- summary(model)[["r.squared"]]
    result_per_variable[i, "adjR2"] <- summary(model)[["adj.r.squared"]]
  }
  result_per_variable
  
  }
```



# relationships 

```{r relationships}


########---------------- ET ---------------------#########

#### GPP vs ET ####

## select variables from the daily non gapfilled measurements 
daily_nGF <- left_join(daily.nGF, BB_met) %>%
  left_join(daily) %>%
  set_period() %>%
  drop_na() %>%
  # mutate(LE = log(LE + 1 - min(LE))^4) 
  mutate(ET = log(ET + 1 - min(ET)))

daily_nGF %>% 
  ggplot(aes(x = (ET), y = GPPgC_f_RF, color = period)) + 
  geom_point() + 
  geom_smooth(method = "loess", se = F)
  

# single model 
model_GPP_ET <- lm(GPPgC_f_RF ~ ET, daily_nGF)
sum_GPP_ET <- summary(model_GPP_ET)
sum_GPP_ET

plot_diagnostics(daily_nGF, model_GPP_ET, type = "GPPgC_f_RF")
shapiro.test(residuals(model_GPP_ET))
ncvTest(model_GPP_ET)

# parallel model 
model_GPP_ET_par <- lm(GPPgC_f_RF ~ ET + period, daily_nGF)
sum_GPP_ET_par <- summary(model_GPP_ET_par)
sum_GPP_ET_par

plot_diagnostics(daily_nGF, model_GPP_ET_par, type = "GPPgC_f_RF")
shapiro.test(residuals(model_GPP_ET_par))
ncvTest(model_GPP_ET_par)

anova(model_GPP_ET, model_GPP_ET_par)

# separate model 
model_GPP_ET_sep <- lm(GPPgC_f_RF ~ ET * period, daily_nGF)
sum_GPP_ET_sep <- summary(model_GPP_ET_sep)
sum_GPP_ET_sep

plot_diagnostics(daily_nGF, model_GPP_ET_sep, type = "GPPgC_f_RF")
shapiro.test(residuals(model_GPP_ET_sep))
ncvTest(model_GPP_ET_sep)

anova(model_GPP_ET_par, model_GPP_ET_sep)  # is the interaction term significant? 



#### Reco vs ET ####

# ## select variables from the daily measurements averaged over 1 week
# daily_nGF <- left_join(daily.nGF, BB_met) %>%
#   left_join(daily) %>%
#   set_period() %>%
#   drop_na() %>%
#   # mutate(ET = log(ET + 1 - min(ET))^4) 
#   mutate(ET = log(ET + 1 - min(ET))^1.5,
#          RecogC = (RecogC + 1 - min(RecogC)))
# 
# daily_nGF %>% 
#   ggplot(aes(x = (ET), y = RecogC, color = period)) + 
#   geom_point() +
#   geom_smooth(method = "loess", se = F)
#   
# 
# # single model 
# model_Reco_ET <- lm(RecogC ~ ET, daily_nGF)
# sum_Reco_ET <- summary(model_Reco_ET)
# sum_Reco_ET
# 
# plot_diagnostics(daily_nGF, model_Reco_ET, type = "RecogC")
# shapiro.test(residuals(model_Reco_ET))
# ncvTest(model_Reco_ET)
# 
# # parallel model 
# model_Reco_ET_par <- lm(RecogC ~ ET + period, daily_nGF)
# sum_Reco_ET_par <- summary(model_Reco_ET_par)
# sum_Reco_ET_par
# 
# plot_diagnostics(daily_nGF, model_Reco_ET_par, type = "RecogC")
# shapiro.test(residuals(model_Reco_ET_par))
# ncvTest(model_Reco_ET_par)
# 
# anova(model_Reco_ET, model_Reco_ET_par)
# 
# # separate model 
# model_Reco_ET_sep <- lm(RecogC ~ ET * period, daily_nGF)
# sum_Reco_ET_sep <- summary(model_Reco_ET_sep)
# sum_Reco_ET_sep
# 
# plot_diagnostics(daily_nGF, model_Reco_ET_sep, type = "RecogC")
# shapiro.test(residuals(model_Reco_ET_sep))
# ncvTest(model_Reco_ET_sep)
# 
# anova(model_Reco_ET_par, sum_Reco_ET_sep)  # is the interaction term significant? 
# 
# 









#######---------------- Stomatal conductance ---------------#########

# slope of relationship between saturation vapor pressure & temp 
s <- 4098 * ( 0.6108 * exp((17.27 * BB1$AIR_TEMP_2M)/( + 273.3))) / (BB1$AIR_TEMP_2M + 273.2)^2 
psy <- psychrometric.constant(BB1$AIR_TEMP_2M, BB1$PA_2M)
Ga <- (BB1$wind_speed / BB1$u.^2) + (2 / 0.4 /BB1$u.)  
Cp <- 1003.5  #specific heat capacity of water in J kg-1 K-1
Cv <- 4.19e6
Eps <- s / psy

Gs_Ryu <-( 1/Ga * (((s / psy * (BB1$NR + BB1$G_corr)) + (BB1$air_density * bigleaf.constants()$cp * Ga * BB1$VPD.y / psy)) / BB1$LE - (s / psy) ) - 1) ^(-1)

BB1 <- BB1 %>% 
  mutate(Gs = Gs_Ryu)

plot_ly(data = BB1, x = ~DATE, y = ~Gs, type = "scatter", mode = "markers") %>% toWebGL()

## filter the outlier
x <-quantile(BB1$Gs,c(0.01,0.99), na.rm = T)
BB1$Gs <- ifelse(BB1$Gs >= x[1] & BB1$Gs <= x[2], BB1$Gs, NA)

plot_ly(data = BB1, x = ~DATE, y = ~Gs, type = "scatter", mode = "markers") %>% toWebGL()

## filter negative values
BB1$Gs <- ifelse(BB1$Gs > 0, BB1$Gs, NA)

# filter outlier again
x <-quantile(BB1$Gs,c(0.01,0.99), na.rm = T)
BB1$Gs <- ifelse(BB1$Gs <= x[2], BB1$Gs, NA)

plot_ly(data = BB1, x = ~DATE, y = ~Gs, type = "scatter", mode = "markers") %>% toWebGL()


## calculate daily, monthly, yearly Gs

daily.Gs <- BB1 %>% 
  group_by(Year_local, jday) %>% 
  summarize(Gs = mean(Gs, na.rm = T)) %>%
  ungroup() %>% 
  mutate(date = as.POSIXct(paste(Year_local, jday, sep = "-"), format = "%Y-%j"), 
         floor_date = floor_date(date, "month")) %>%
  set_period() %>% 
  filter(!is.na(date))

monthly.Gs <- daily.Gs %>% 
  group_by(period, floor_date) %>% 
  summarize(Gs = mean(Gs, na.rm = T)) %>%
  ungroup()

yearly.Gs <- daily.Gs %>% 
  group_by(Year_local) %>% 
  summarize(Gs = mean(Gs, na.rm = T)) %>% 
  ungroup()

plot_ly(data = daily.Gs, x = ~date, y = ~Gs, type = "scatter", mode = "markers") %>% toWebGL()

# monthly Gs value per year

monthly.Gs <- monthly.Gs %>% 
  group_by(period) %>%
  arrange(floor_date) %>%
  mutate(order = row_number()) %>%
  ungroup() %>%
  mutate(day_label = case_when(day(floor_date) == 1L ~ format(floor_date, "%b"),
                     TRUE ~ NA_character_))

x_break <- monthly.Gs$order[!is.na(monthly.Gs$day_label)] [1:12]
x_label <- monthly.Gs$day_label[!is.na(monthly.Gs$day_label)]
x_label

monthly.Gs %>%
  ggplot(aes(x = order, y = Gs, col = factor(period))) + 
  geom_line(size = 0.7) + 
  geom_point() + 
  scale_x_continuous(
    breaks = unique(x_break),
    labels = unique(x_label)) +
  theme_bw() +
  labs(x = "", 
       y = "Gs (m/s)", 
       col = "")




######----------------- Light response curve ---------------########

#### get curve for each year ####
light_resp <- data.frame(period = NA, 
                         alpha = NA, 
                         alpha_se = NA, 
                         GPPmax = NA, 
                         GPPmax_se = NA,
                         RMSE = NA)
year_period <- period
for(i in 1:length(period)){
  GS_dat <- BB1 %>%  # use half-hourly values
  dplyr::select(c(DATE, date, jday, month_local, Year_local, time, period, season,
            Tau, ET, RH, u., jday, co2_flux, ch4_flux, NEE_f,
            Reco, GPP_f, GPP_DT, Reco_DT, FCH4_f, FCH4_gf_RF,
            NEE_f_RF, GPP_f_RF, INCOMING_PAR)) %>%
  dplyr::rename(year_local = Year_local, 
                PARin = INCOMING_PAR) %>% 
  set_period() %>% set_season(date = BB1$date) %>%
  drop_na() %>% 
  filter(season == "growing season" & PARin >10 & period == year_period[i])

  mod <- nls(GPP_f ~ a*PARin*b/(a*PARin+b), start=list(a = 0.01, b = 5), data = GS_dat)
  
  coef.mod <- coef(mod)
  coef.mod
  a.GPP <- as.numeric(coef.mod[1])
  b.GPP <- as.numeric(coef.mod[2])
  
  print(ggplot(GS_dat, aes(PARin, GPP_f)) + geom_point() + 
    stat_function(fun=function(x) (a.GPP*x)*b.GPP/(a.GPP*x+b.GPP), colour = "red") +
        xlab(bquote('Incoming PAR (umol'  ~m^-2~day^-1*')'))+
    theme_bw())
  
  light_resp[i, "period"] <- period[i]
  light_resp[i, "alpha"] <- a.GPP
  light_resp[i, "alpha_se"] <- summary(mod)[["parameters"]][1,2]
  light_resp[i, "GPPmax"] <- b.GPP
  light_resp[i, "GPPmax_se"] <- summary(mod)[["parameters"]][1,2]
  light_resp[i, "RMSE"] <- summary(mod)[["sigma"]]
}


####  test whether coeff differ between years #####
GS_dat <- BB1 %>%
  dplyr::select(c(DATE, date, jday, month_local, Year_local, time, period, season,
            Tau, ET, RH, u., jday, co2_flux, ch4_flux, NEE_f,
            Reco, GPP_f, GPP_DT, Reco_DT, FCH4_f, FCH4_gf_RF,
            NEE_f_RF, GPP_f_RF, INCOMING_PAR)) %>%
  dplyr::rename(year_local = Year_local, 
                PARin = INCOMING_PAR) %>% 
  set_period() %>% set_season(date = BB1$date) %>%
  drop_na() %>% 
  filter(season == "growing season" & PARin > 18, GPP_f > 0)


mod <- gnls(GPP_f ~ a*PARin*b/(a*PARin+b), 
            start=list(a = 0.02, b = 5), data = GS_dat)

mod.year <- gnls(GPP_f ~ (a*PARin*b)/(a*PARin+b), data = GS_dat, 
            start = list(a =  rep(0.01, 5), 
                         b = rep(7, 5)), 
            params = list(a ~ period - 1, 
                          b ~ period -1))

anova(mod, mod.year)


#### plotting all years ####
# get color codes 
cols <- gg_color_hue(5)  # 5 is number of factors (period)


(GS.LR <- BB1 %>%
  dplyr::select(c(DATE, date, jday, month_local, Year_local, time, period, season,
            Tau, ET, RH, u., jday, co2_flux, ch4_flux, NEE_f,
            Reco, GPP_f, GPP_DT, Reco_DT, FCH4_f, FCH4_gf_RF,
            NEE_f_RF, GPP_f_RF, INCOMING_PAR)) %>%
  dplyr::rename(year_local = Year_local, 
                PARin = INCOMING_PAR) %>% 
  set_period() %>% set_season(date = BB1$date) %>%
  drop_na() %>% 
  filter(season == "growing season" & PARin >10) %>%
  ggplot(aes(PARin, GPP_f), group = period) + geom_point(aes(color = period))+
  stat_function(fun=function(x) (light_resp[1, "alpha"]*x)*light_resp[1, "GPPmax"]/(light_resp[1, "alpha"]*x+light_resp[1, "GPPmax"]), color = cols[1], size = 1.2) +
  stat_function(fun=function(x) (light_resp[2, "alpha"]*x)*light_resp[2, "GPPmax"]/(light_resp[2, "alpha"]*x+light_resp[2, "GPPmax"]), color = cols[2], size = 1.2) +
  stat_function(fun=function(x) (light_resp[3, "alpha"]*x)*light_resp[3, "GPPmax"]/(light_resp[3, "alpha"]*x+light_resp[3, "GPPmax"]), color = cols[3], size = 1.2) +
  stat_function(fun=function(x) (light_resp[4, "alpha"]*x)*light_resp[4, "GPPmax"]/(light_resp[4, "alpha"]*x+light_resp[4, "GPPmax"]), color = cols[4], size = 1.2) +
  stat_function(fun=function(x) (light_resp[5, "alpha"]*x)*light_resp[5, "GPPmax"]/(light_resp[5, "alpha"]*x+light_resp[5, "GPPmax"]), color = cols[5], size = 1.2) +

       # xlab(bquote('Incoming PAR ('*mu~'mol'~m^-2~s^-1*')'))+
          #ylab(bquote('GPP ('*mu~'mol' ~m^-2~s^-1*')'))+
   ylab(expression(paste("GPP (",mu,"mol"," ", m^-2," ", s^-1, ")")))+
      xlab(expression(paste("Incoming PAR (",mu,"mol"," ", m^-2," ", s^-1, ")")))+
   #ylab(expression(paste("Power [",mu, V^2,"]")))
  theme(axis.text = element_text(size = 14),
          axis.title.x = element_text(size = 15),
         axis.title.y = element_text(size = 15))+
  theme_bw())

ggsave("plots/light_response.jpg", width = 7, height = 4, dpi=300)

write.csv(light_resp, "df/light_response.csv")





######----------------- PAR vs SWin -----------------------########


daily_nGF <- left_join(daily.nGF, BB_met) %>%
  left_join(daily) %>%
  set_period() %>%
  drop_na() %>% 
  filter(PARin > 10 & season == "growing season") %>%
  mutate(SWin = SWin* d.avg * 1e-6,  # J m-2 s-1 to get MJ m-2 d-1
         PARin = PARin / 4.6,  # convert from mol m2 day -1  to MJ m-2 d-1
         SI = PARin/SWin
         )
  
daily_nGF %>%  
  ggplot(aes(x = SWin, y = PARin, color = period)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = F) + 
  theme_bw()

daily_nGF %>%  
  ggplot(aes(x = date, y = SI, color = period)) + 
  geom_point() + 
  theme_bw()
  
# single model 
model_PAR_SWin <- lm(PARin ~ SWin, daily_nGF)
sum_PAR_SWin <- summary(model_PAR_SWin)
sum_PAR_SWin

plot_diagnostics(daily_nGF, model_PAR_SWin, type = "PARin")
shapiro.test(residuals(model_PAR_SWin))
ncvTest(model_PAR_SWin)

# parallel model 
model_PAR_SWin_par <- lm(PARin ~ SWin + period, daily_nGF)
sum_PAR_SWin_par <- summary(model_PAR_SWin_par)
sum_PAR_SWin_par

plot_diagnostics(daily_nGF, model_PAR_SWin_par, type = "PARin")
shapiro.test(residuals(model_PAR_SWin_par))
ncvTest(model_PAR_SWin_par)

anova(model_PAR_SWin, model_PAR_SWin_par)

# separate model 
model_PAR_SWin_sep <- lm(PARin ~ SWin * period, daily_nGF)
sum_PAR_SWin_sep <- summary(model_PAR_SWin_sep)
sum_PAR_SWin_sep

plot_diagnostics(daily_nGF, model_PAR_SWin_sep, type = "PARin")
shapiro.test(residuals(model_PAR_SWin_sep))
ncvTest(model_PAR_SWin_sep)

anova(model_PAR_SWin_par, model_PAR_SWin_sep)

```




# for CO2


## HOS approach

```{r HOS approach for NEE using weekly data, include = F}

## select variables from the daily measurements averaged over 1 week
weekly_nGF <- left_join(weekly.nGF, weekly.met) %>% 
  dplyr::select(c(floor_date, co2gC, TS.5, RH, PARin,
                  VPD.y, Precip, PA_2M, Ta, wtd, LE, H, ustar)) %>%
  rename(date = floor_date) %>% 
  set_period() %>%
  drop_na() 


## check data 
windows()
pairs(weekly_nGF %>% dplyr::select(-c(date, period)),
      data = weekly_nGF,
      main = "scatterplot matrix for mco2 ")

#let's check real quick

# variable selection using AIC 
# no x variable, the null model
model.null <- lm(co2gC ~ 1, data = weekly_nGF %>% dplyr::select(-c(date, period))) 
# all x variables
model.full <- lm(co2gC ~ ., data = weekly_nGF %>% dplyr::select(-c(date, period))) 

# Start with null model
model.step <- stepAIC(model.null, 
                      scope = list(upper = ~TS.5 + RH + PARin + VPD.y + 
                                     # LE + H + ustar +
                                     Precip + PA_2M + Ta + wtd + Ta, 
                                   lower = ~1),
                      trace = T)

# in order: PARin, TS.5, wtd, Precip, PA_2M


####-------------- variable selection------------------####

cor(weekly_nGF %>% dplyr::select(-c(date, period)))


# weekly_nGF1 <- weekly_nGF %>%
#   mutate(co2gC = co2gC^2,
#          wtd = exp(wtd + 1 - min(wtd))^(-0.5),
#          TS.5 = TS.5^2,
#          LE = log(LE + 1 - min(LE))) %>%
#   dplyr::select(-c(Ta, VPD.y, H, PARin))


# weekly_nGF1 <- weekly_nGF %>%
#   mutate(co2gC = log(co2gC + 1 - min(co2gC))^2,
#          TS.5 = (TS.5 + 1 - min(TS.5))^3,
#          LE = log(LE + 1 - min(LE))^(2),
#          PARin = log(PARin + 1 - min(PARin))^2, 
#          wtd = exp(wtd + 1 - min(wtd))) %>%
#   dplyr::select(-c(Ta, VPD.y, H, PARin))

weekly_nGF1 <- weekly_nGF %>%
  mutate(co2gC = log(co2gC + 1 - min(co2gC))^2,
         TS.5 = (TS.5 + 1 - min(TS.5))^3,
         LE = log(LE + 1 - min(LE))^(2),
         PARin = log(PARin + 1 - min(PARin))^2, 
         wtd = exp(wtd + 1 - min(wtd)), 
         Precip = log(Precip + 1 - min(Precip)))

# cor(weekly_nGF1%>% dplyr::select(-c(date, period)))

## check data
pairs(weekly_nGF1 %>% dplyr::select(c(co2gC, TS.5, wtd, PARin, Precip)),
      data = weekly_nGF1,
      main = "scatterplot matrix for mco2 ")



#####------------------- MODEL SELECTION FOR SINGLE LINE MODEL --------------------#####
# no need to exclude variables w multicollinearity. StepAIC should exclude those automatically 

# model selection
co2gC_subset <- regsubsets(co2gC~., 
                           data = weekly_nGF1 %>% dplyr::select(-c(date, period)), 
                           nbest = 5, nvmax = 3)

s <- summary(co2gC_subset)

result_stat <- data.frame(s$which, s$rsq, s$adjr2, s$bic)

# order results by decreasing adjr2
result_stat[order(-result_stat$s.adjr2), ]

# order results by increasing bic
result_stat[order(result_stat$s.bic), ]


#### try the first model (highest adj R2) #### 

model_1 <- lm(co2gC ~ TS.5 + Precip + wtd, data = weekly_nGF1) 
sum_1 <- summary (model_1)
sum_1 

# check multicollinearity
vif(model_1)

plot_diagnostics(weekly_nGF1, model_1)
shapiro.test(residuals(model_1))


##### try best model w/ 3 predictors ####

model_2 <- lm(co2gC ~ TS.5 + wtd + PARin, data = weekly_nGF1) 
sum_2 <- summary (model_2)
sum_2 

# check multicollinearity
vif(model_2)

plot_diagnostics(weekly_nGF1, model_2)
shapiro.test(residuals(model_2))
ncvTest(model_2)
# residuals are normal, but homogeneity assumption is not quite met


####---------------- SEPARATE LINES MODEL ---------------####

model_2_sep <- lm(co2gC ~ (TS.5 + wtd + PARin) * period, data = weekly_nGF1)
sum_2_sep <- summary(model_2_sep)
sum_2_sep


plot_diagnostics(weekly_nGF1, model_2_sep)
shapiro.test(residuals(model_2_sep))
ncvTest(model_2_sep)

# joint test: 
anova(model_2, model_2_sep)


Anova(model_2, type = c("III"))
Anova(model_2_sep, type = c("III"))


####-------------- PARTITIONING THE VARIATIONS --------------#### 

est_2_single <- calc_model(weekly_nGF1, model_2)
est_2_sep <- calc_model(input = weekly_nGF1, model_2_sep)

#### SSf (sums of squares of deviation explained by the functional change) ####

#  sum((estimated NEE separate lines model - estimated NEE single model)^2)
SSf <- sum((est_2_sep$yhat - est_2_single$yhat)^2)


#### SSe (SS of random error) ####
SSe <- sum((est_2_sep$observed - est_2_sep$yhat)^2)

#### SSic (SS of interannual climatic variability)

# interannual deviations of met variables = daily NEE - mean NEE each year

est_2_sep <- est_2_sep %>% 
  mutate(week = lubridate::week(date)) %>%
  group_by(week) %>% 
  mutate(yhat_mean_year = mean(yhat)) %>% 
  ungroup() %>% 
  mutate(yhat_mean = mean(yhat))

SSic <- sum((est_2_sep$yhat - est_2_sep$yhat_mean_year)^2)

#### SSsc (SS of seasonal climatic variation)


SSsc <- sum((unique(est_2_sep$yhat_mean_year) - 
               est_2_sep$yhat_mean[1])^2)


#### SSt (SS total) ####
SSt <- SSf + SSic + SSsc + SSe  
SSt_not_signifc <- SSic + SSsc + SSe  

sum((est_2_sep$yhat - est_2_sep$yhat_mean)^2)


#### combine result ####

# Percent contribution of each component to the interannual variability of NEE
NEE_HOS <- data.frame(SSf = SSf/SSt * 100, 
                      SSic = SSic/SSt * 100,
                      SSsc = SSsc/SSt * 100,
                      SSe = SSe/SSt * 100)

NEE_HOS_not_signif <- data.frame(SSic = SSic/SSt_not_signifc * 100,
                                 SSsc = SSsc/SSt_not_signifc * 100,
                                 SSe = SSe/SSt_not_signifc * 100)

####-------------------- PLOTTING THE MODELS ------------------------------####

plot_ly(data = est_2_sep, x = ~date, y = ~yhat, type = "scatter", mode = "lines", name = "separate lines model") %>%
  add_trace(data = est_2_single, x = ~date, y = ~yhat, type = "scatter", mode = "lines", name = "single line model") %>%
  add_trace(data = est_2_sep, x = ~date, y = ~observed, type = "scatter", mode = "markers", name = "observed")




```

```{r NEE HOS result: plot & df, echo = F}

#####-------------------- PLOTTING -----------------------#####


NEE_HOS_weekly_plot <- ggplot() + 
  geom_line(aes(x = est_2_sep$date, y = est_2_sep$yhat, linetype = "separate line model"), size = 0.7) + 
  geom_line(aes(x = est_2_single$date, y = est_2_single$yhat, linetype = "single line model"), size = 0.7) + 
  geom_point(aes(x = est_2_sep$date, y = est_2_sep$observed, shape = "observed")) +
  scale_linetype_manual(values = c("separate line model" = "solid", 
                                "single line model" = "dashed")) +
  scale_shape_manual(values = c("observed" = 16)) + 
  labs(x = "year", 
     y = "NEE (gC/day)", 
     linetype = "", 
     shape = "") + 
  theme_bw()

print(NEE_HOS_weekly_plot)
ggsave("plots/NEE_HOS_weekly_plot.jpg")

####-------------------- SAVE DF -----------------------#####

write.csv(NEE_HOS, "df/NEE_HOS_weekly.csv")
write.csv(NEE_HOS_not_signif, "df/NEE_HOS_weekly_not_signif.csv")


NEE_HOS %>% flextable() 

```


## MLR for each year

```{r NEE yearly MLR, include = F } 

## select variables from the daily measurements
daily_nGF <- left_join(daily.nGF, BB_met) %>% 
  dplyr::select(c(date, co2gC, TS.5, RH, PARin,
                  VPD.y, Precip, PA_2M, Ta, wtd, LE, H, ustar)) %>%
  set_period() %>%
  drop_na() 

## transformation 
daily_nGF1 <- daily_nGF %>%
  mutate(co2gC = log(co2gC + 1 - min(co2gC))^3,
         TS.5 = (TS.5 + 1 - min(TS.5))^2,
         LE = log(LE + 1 - min(LE))^(2),
         Ta = (Ta + 1 - min(Ta))^2, 
         wtd = exp(wtd + 1 - min(wtd)), 
         PARin = log(PARin + 1 - min(PARin))^2, 
         VPD.y = log(VPD.y + 1 - min(VPD.y))^2)

cor(daily_nGF1 %>% dplyr::select(-c(date, period)))

# define the variables to be included in the model 
scope <-  list(upper = ~TS.5 + RH + Precip + PA_2M + wtd + 
                 # LE + H +
                 PARin + Ta + VPD.y ,  
                                   lower = ~1)

##---------------- period 2015-2016 ---------------##


period <- unique(daily_nGF1$period)

for(i in 1: length(period)){
  if(i == 1){ 
    co2_MLR_yearly <- calc_yearly_MLR(daily_nGF1, period[i], scope, "co2gC") %>% 
  mutate(period = period[i])
  } else { 
    co2_MLR_yearly <- rbind(co2_MLR_yearly, 
                            calc_yearly_MLR(daily_nGF1, period[i], scope, "co2gC", k = 3.841) %>% 
                              mutate(period = period[i]) )}
 
  }

# k = 3.8 from qchisq(0.05, 1, lower.tail = F) set alpha for individual variable to 0.05

co2_MLR_yearly$variable <- gsub("[+] ", "", co2_MLR_yearly$variable)

write.csv(co2_MLR_yearly, "df/co2_MLR_yearly.csv")

```

```{r NEE yearly MLR result: df, echo = F} 

co2_MLR_yearly %>% flextable()

```






# for CH4 

## HOS approach
```{r HOS approach using weekly data, include = F}

# select variables 
weekly_nGF <- left_join(weekly.nGF, weekly.met) %>% 
  left_join(weekly.GF) %>%
  dplyr::select(c(floor_date, ch4gC, co2gC, GPP_f_RF, TS.5, RH, PARin, 
                  VPD.y, Precip, PA_2M, Ta, wtd, LE, H, ustar)) %>%
  rename(date = floor_date) %>% 
  set_period() %>%
  drop_na() 


## check data 
windows()
pairs(weekly_nGF %>% dplyr::select(-c(date, period)),
      data = weekly_nGF,
      main = "scatterplot matrix for mco2 ")


#let's check real quick

# variable selection using AIC 
# no x variable, the null model
model.null <- lm(ch4gC ~ 1, data = weekly_nGF %>% dplyr::select(-c(date, period, co2gC))) 
# all x variables
model.full <- lm(ch4gC ~ ., data = weekly_nGF %>% dplyr::select(-c(date, period, co2gC))) 

# Start with null model
model.step <- stepAIC(model.null, 
                      scope = list(upper = ~GPP_f_RF + TS.5 + RH + PARin + VPD.y + 
                                     # LE + H + ustar +
                                     Precip + PA_2M + Ta + wtd, 
                                   lower = ~1),
                      trace = T)

# in order: Ta, wtd, LE, H, RH, co2gC, RH


####-------------- variable selection------------------####

cor(weekly_nGF %>% dplyr::select(-c(date, period)))



# weekly_nGF1 <- weekly_nGF %>%drop_na()%>%
#   mutate(ch4gC = (log10(ch4gC + 1 - min(ch4gC)))^0.6,
#          co2gC = (exp(co2gC + 1 - min(co2gC)))^2,
#          GPP = (GPP_f_RF + 1 - min(GPP_f_RF))^3,
#          TS.5 = exp((TS.5 + 1 - min(TS.5)))^2,
#          Ta = (exp(Ta + 1 - min(Ta)))^2,
#          wtd = (exp(wtd + 1 - min(wtd)))^0.8,
#          LE = log10(LE + 1 - min(LE))^2,
#          H = (H + 1 - min(H)), 
#          PARin = log10(PARin + 1 - min(PARin))^2) 
# %>%
#   dplyr::select(-c(PARin, VPD.y, GPP_f_RF))


weekly_nGF1 <- weekly_nGF %>%drop_na()%>%
  mutate(ch4gC = (log10(ch4gC + 1 - min(ch4gC)))^0.5,
         co2gC = (exp(co2gC + 1 - min(co2gC)))^2,
         # GPP = (GPP_f_RF + 1 - min(GPP_f_RF))d^3,
         GPP = log10(GPP_f_RF + 1 - min(GPP_f_RF))^2, 
         TS.5 = (log(TS.5 + 1 - min(TS.5))^2),
         Ta = (log(Ta + 1 - min(Ta))^2),
         wtd = (exp(wtd + 1 - min(wtd))^2),
         LE = log10(LE + 1 - min(LE))^2,
         H = (H + 1 - min(H)), 
         PARin = log10(PARin + 1 - min(PARin))^2) %>% 
  dplyr::select(-c(GPP_f_RF))


cor(weekly_nGF1%>% dplyr::select(-c(date, period)))

# check data
pairs(weekly_nGF1 %>% dplyr::select(c(ch4gC, GPP, Ta, TS.5, wtd, LE, H, PARin)),
      data = weekly_nGF1,
      main = "scatterplot matrix for mco2 ")


model_x <- lm(ch4gC ~ wtd + GPP + TS.5 , data = weekly_nGF1) 
plot_diagnostics(weekly_nGF1, model_x, "ch4gC")
shapiro.test(residuals(model_x))
ncvTest(model_x)



#let's check real quick

# variable selection using AIC 
# no x variable, the null model
model.null <- lm(ch4gC ~ 1, data = weekly_nGF1 %>% dplyr::select(-c(date, period, co2gC))) 
# all x variables
model.full <- lm(ch4gC ~ ., data = weekly_nGF1 %>% dplyr::select(-c(date, period, co2gC))) 

# Start with null model
model.step <- stepAIC(model.null, 
                      scope = list(upper = ~GPP + TS.5 + RH + PARin + VPD.y + 
                                     # LE + H + ustar +
                                     Precip + PA_2M + Ta + wtd, 
                                   lower = ~1),
                      trace = T)




#####------------------- MODEL SELECTION FOR SINGLE LINE MODEL --------------------#####

# model selection
ch4gC_subset <- regsubsets(ch4gC~., data = weekly_nGF1 %>% dplyr::select(-c(date, period, co2gC)), nbest = 5, nvmax = 3)
s <- summary(ch4gC_subset)

result_stat <- data.frame(s$which, s$rsq, s$adjr2, s$bic)

# order results by decreasing adjr2
result_stat[order(-result_stat$s.adjr2), ]

# order results by increasing bic
result_stat[order(result_stat$s.bic), ]


#### try the first model (highest adj R2) #### 

model_2 <- lm(ch4gC ~ wtd + GPP, data = weekly_nGF1) 
sum_2 <- summary (model_2)
sum_2 

plot_diagnostics(weekly_nGF1, model_2, "ch4gC")
shapiro.test(residuals(model_2))
ncvTest(model_2)
vif(model_2)

####---------------- SEPARATE LINES MODEL ---------------####

model_2_sep <- lm(ch4gC ~ (wtd + GPP) * period, data = weekly_nGF1)
sum_2_sep <- summary(model_2_sep)
sum_2_sep


plot_diagnostics(weekly_nGF1, model_2_sep, "ch4gC")
shapiro.test(residuals(model_2_sep))
ncvTest(model_2_sep)

# joint test: 
anova(model_2, model_2_sep)


Anova(model_2, type = c("III"))
Anova(model_2_sep, type = c("III"))


####-------------- PARTITIONING THE VARIATIONS --------------#### 

est_2_single <- calc_model(weekly_nGF1, model_2, "ch4gC")
est_2_sep <- calc_model(input = weekly_nGF1, model_2_sep, "ch4gC")

#### SSf (sums of squares of deviation explained by the functional change) ####

#  sum((estimated NEE separate lines model - estimated NEE single model)^2)
SSf <- sum((est_2_sep$yhat - est_2_single$yhat)^2)


#### SSe (SS of random error) ####
SSe <- sum((est_2_sep$observed - est_2_sep$yhat)^2)

#### SSic (SS of interannual climatic variability)

# interannual deviations of met variables = daily NEE - mean NEE each year

est_2_sep <- est_2_sep %>% 
  mutate(week = lubridate::week(date)) %>%
  group_by(week) %>% 
  mutate(yhat_mean_year = mean(yhat)) %>% 
  ungroup() %>% 
  mutate(yhat_mean = mean(yhat))

SSic <- sum((est_2_sep$yhat - est_2_sep$yhat_mean_year)^2)

#### SSsc (SS of seasonal climatic variation)


SSsc <- sum((unique(est_2_sep$yhat_mean_year) - 
               est_2_sep$yhat_mean[1])^2)


#### SSt (SS total) ####
SSt <- SSf + SSic + SSsc + SSe

sum((est_2_sep$yhat - est_2_sep$yhat_mean)^2)


#### combine results ####

# Percent contribution of each component to the interannual variability of NEE
fCH4_HOS <- data.frame(SSf = SSf/SSt * 100, 
                      SSic = SSic/SSt * 100,
                      SSsc = SSsc/SSt * 100,
                      SSe = SSe/SSt * 100)


#####-------------------- PLOTTING -----------------------#####

plot_ly(data = est_2_sep, x = ~date, y = ~yhat, type = "scatter", mode = "lines", name = "separate lines model") %>% 
  add_trace(data = est_2_single, x = ~date, y = ~yhat, type = "scatter", mode = "lines", name = "single line model") %>%
  add_trace(data = est_2_sep, x = ~date, y = ~observed, type = "scatter", mode = "markers", name = "observed")



```

```{r CH4 HOS result: plot & df, echo = F}

#####-------------------- PLOTTING -----------------------#####

fCH4_HOS_weekly_plot <- ggplot() + 
  geom_line(aes(x = est_2_sep$date, y = est_2_sep$yhat, linetype = "separate line model"), size = 0.7) + 
  geom_line(aes(x = est_2_single$date, y = est_2_single$yhat, linetype = "single line model"), size = 0.7) + 
  geom_point(aes(x = est_2_sep$date, y = est_2_sep$observed, shape = "observed")) +
  scale_linetype_manual(values = c("separate line model" = "solid", 
                                "single line model" = "dashed")) +
  scale_shape_manual(values = c("observed" = 16)) + 
  labs(x = "year", 
     y = "NEE (gC/day)", 
     linetype = "", 
     shape = "") + 
  theme_bw()

print(fCH4_HOS_weekly_plot)
ggsave("plots/fCH4_HOS_weekly_plot.jpg")

####-------------------- SAVE DF -----------------------#####

write.csv(fCH4_HOS, "df/fCH4_HOS_weekly.csv")

fCH4_HOS %>% flextable()

```

## MLR for each year 


```{r CH4 yearly MLR, eval = F, include = F} 

## select variables from the daily measurements
daily_nGF <- left_join(daily.nGF, BB_met) %>%
  left_join(daily) %>%
  dplyr::select(c(date, ch4gC, co2gC, GPP_f_RF, TS.5, RH, PARin,
                  VPD.y, Precip, PA_2M, Ta, wtd, LE, H, ustar)) %>%
  set_period() %>%
  drop_na()

## transformation
daily_nGF1 <- daily_nGF %>%drop_na()%>%
  mutate(ch4gC = (log10(ch4gC + 1 - min(ch4gC)))^0.5,
         # co2gC = (exp(co2gC + 1 - min(co2gC)))^2,
         GPP_f_RF = (GPP_f_RF + 1 - min(GPP_f_RF))^2, 
         TS.5 = exp((TS.5 + 1 - min(TS.5)))^2,
         wtd = (exp(wtd + 1 - min(wtd))),
         LE = log10(LE + 1 - min(LE))^2,
         H = (H + 1 - min(H))) 

cor(daily_nGF1%>% dplyr::select(-c(date, period)))


# define the variables to be included in the model
scope <-  list(upper = ~GPP_f_RF + TS.5 + RH + Ta +
                 H + LE + 
                 PARin + VPD.y + Precip + PA_2M + wtd, 
               lower = ~1)

##---------------- period 2015-2016 ---------------##


period <- unique(daily_nGF1$period)

for(i in 1: length(period)){
  if(i == 1){
    ch4_MLR_yearly <- calc_yearly_MLR(daily_nGF1, period[i], scope, "ch4gC") %>%
  mutate(period = period[i])
  } else {
    ch4_MLR_yearly <- rbind(ch4_MLR_yearly,
                            calc_yearly_MLR(daily_nGF1, period[i], scope, "ch4gC", k = 3.8) %>%
                              mutate(period = period[i]) )}

  }


ch4_MLR_yearly$variable <- gsub("[+] ", "", ch4_MLR_yearly$variable)
write.csv(ch4_MLR_yearly, "df/ch4_MLR_yearly.csv")
```

```{r CH4 yearly MLR result: df, echo = F} 

ch4_MLR_yearly %>% flextable()

```





# Others
